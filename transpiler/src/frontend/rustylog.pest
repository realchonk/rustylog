
Function = { FnMacro? ~ "pub"? ~ "fn" ~ "(" ~ Args? ~ ")" ~ ("->" ~ Type)? ~ BlockStmt }

FnMacro = { "#[always_ff(" ~ AlwaysFFArgs ~ ")]" | "#[always_comb]" }
AlwaysFFArg = { Ident ~ (":" ~ Trigger)? }
AlwaysFFArgs = { AlwaysFFArg ~ ("," ~ AlwaysFFArg)* ~ ","? }

Args = { (Arg | SelfRef) ~ ("," ~ Arg)* ~ ","? }
Arg = { Ident ~ ":" ~ Type }
SelfRef = { "&" ~ "mut"? ~ "self" }

Type = { SubType | IOType ~ "<" ~ SubType ~ ">" }
SubType = { "[" ~ SubType ~ ";" ~ Index ~ "]" | "logic" | "tri" | QName }


Statement = { IfStmt
		  	| AssignStmt
			| BlockStmt
}

AtomExpr = _{ Int
		   | SubExpr
		   | ArrayExpr
		   | ConstructExpr
		   | CallExpr
		   | NameExpr
}
ExprList = _{ Expression ~ ("," ~ Expression)* ~ ","? }
Constructor = { Ident ~ (":"  ~ Expression)? }
ConstructorList = _{ Constructor ~ ("," ~ Constructor)* ~ ","? }

NameExpr = { VName }
CallExpr = { VName ~ "(" ~ ExprList? ~ ")" }
ArrayExpr = { "[" ~ ExprList? ~ "]" }
ConstructExpr = { QName ~ "{" ~ ConstructorList? ~ "}" }
SubExpr = { "(" ~ Expression ~ ")" }

IndexExpr = { AtomExpr ~ ("[" ~ Index ~ "]")* }
UnaryExpr = { IndexExpr | UnaryOp ~ UnaryExpr }
MulDivExpr = { UnaryExpr ~ (MulDivOp ~ UnaryExpr)* }
AddSubExpr = { MulDivExpr ~ (AddSubOp ~ MulDivExpr)* }
Expression = { AddSubExpr }

BlockStmt = { "{" ~ Statement* ~ "}" }
IfStmt = { "if" ~ Expression ~ BlockStmt ~ ("else" ~ BlockStmt)? }
AssignStmt = { VName ~ AssignOp ~ Expression ~ ";" }


VName = { ("self" ~ ".")? ~ Ident }
QName = { (Ident ~ "::")* ~ Ident }
Index = { Int ~ (".." ~ Int)? }

Int = @{ ASCII_DIGIT+ }
Ident = @{ ('a'..'z' | 'A'..'Z' | "_") ~ ('a'..'z' | 'A'..'Z' | '0'..'9' | "_")* }
UnaryOp = @{ "+" | "-" | "~" }
MulDivOp = @{ "*" | "/" }
AddSubOp = @{ "+" | "-" }
AssignOp = @{ "=" | "<=" }
Trigger = @{ "posedge" | "negedge" }
IOType = @{ "Input" | "Output" | "InOut" }

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }