#+NAME: A Rust-like hardware description language, transpiled directly into (System-)Verilog
#+AUTHOR: Benjamin St√ºrz <benni@stuerz.xyz>

* Introduction
This projects attempts to create a Rust-like hardware description language.
Note that this has nothing to do with Rust itself, it just has a very similar syntax to Rust.
At the moment this project is in it's early planning and development stage.

* How it should work
You write some Rust-like HDL and use the transpiler to turn it into (System-)Verilog.

* Contributing
I mainly want your opinions on the syntax of this HDL.
But code improvements are welcome too!

* Syntax/Grammar
This is not the final syntax/grammar, it may change drastically!
#+begin_src text
<ident> := [a-zA-Z_]+;
<int> := [0-9]+;

<vname> := ('self' '.')? <ident>;
<qname> := (<ident> '::')* <ident>;
<qvname> := <qname> | <vname>;

<index> := <int> ('..' <int>)?;

<subtype> := 'Logic'
		  	 | 'Tri'
		  	 | '[' <subtype> ';' <index> ']'
			 ;

<type> := ('Input' | 'Output' | 'InOut') '<' <subtype> '>'
	   	  | <subtype>
		  ;
	
<expression> := <vname>
			 	| '~' <expression>
			 	| <expression> ['+' | '-'] <expression>
				| <qname> '{' (<ident> (':' <expression>)? ',')* '}'
				| <qvname> '(' (<expression> ',')* ')'
				| <vname> '[' <index> ']'
				;

<block-stmt> := '{' <statement>* '}';
				
<statement> := 'if' <expression> <block-stmt> ('else' <block-stmt>)?
			   | <vname> ('<=' | '=') <expression>
			   | <block-stmt>
			   ;

<trigger> := 'posedge' | 'negedge' | 'pos' | 'neg';
// TODO: find appropriate name for <sensor>
<sensor> := <ident> (':' <trigger>)?;
<fn-macro> := '#[always_ff(' (<sensor> ',')* ')]'
		   	  | '#[always_comb]'
			  ;
			  
<declaration> := <ident> ':' <type>;
			  
<function> := <fn-macro> 'pub'? 'fn' <ident> '(' (<declaration> ',')* ')' ('->' <type>)? <block-stmt>;

<impl> := 'impl' <ident> '{' <function>* '}';
<struct> := 'pub'? 'struct' <ident> '{' ('pub'? <declaration> ',')* '}';
<element> := <impl> | <struct>;
<program> := <element>*;
#+end_src
* Examples
** Accumulator (from llhd.io)
#+begin_src rust
pub struct Accumulator {
	pub clk: Input<Logic>,
	pub direction: Input<Logic>,
	pub increment: Input<[Logic; 16]>,
	pub result: Output<[Logic; 16]>,

	next: [Logic; 16],
}

impl Accumulator {
	pub fn new(clk: Input<Logic>, direction: Input<Logic>, increment: Input<[Logic; 16]>, result: Output<[Logic; 16]>) -> Self {
		Self {
			clk,
			direction,
			increment,
			result,
			// TODO: next
		}
	}
	
	#[always_comb]
	fn increment(&mut self) {
		if self.direction {
			self.result = self.result + self.increment;
		} else {
			self.result = self.result - self.increment;
		}
	}

	#[always_ff(clk: posedge)]
	fn load_result(&mut self) {
		self.result <= self.next;
	}
}

pub struct Top {
	acc: Accumulator,
}

impl Top {
	pub fn new(clk: Input<Logic>, direction: Input<Logic>, increment: Input<[Logic; 16]>, result: Output<[Logic; 16]>) -> Top {
		Self {
			acc: Accumulator::new(clk, direction, increment, result),
		}
	}
}
#+end_src

* Resources
** [[http://llhd.io][LLHD]]
** [[https://sutherland-hdl.com/papers/2013-SNUG-SV_Synthesizable-SystemVerilog_paper.pdf][Synthesizable Verilog]]

* TODOs
** type X = Y;
** Syntactic Sugar for State Machines
** Look into nom
** Integration with LLHD
** Look into [[https://github.com/B-Lang-org/bsc][Bluespec]]
