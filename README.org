#+NAME: A Rust-like hardware description language, transpiled directly into SystemVerilog
#+AUTHOR: Benjamin St√ºrz <benni@stuerz.xyz>

* Introduction
This projects attempts to create a Rust-like hardware description language.
Note that this has nothing to do with Rust itself, it just has a very similar syntax to Rust.
At the moment this project is in it's early planning stage.
No code has been written on the Transpiler front, yet.

* How it should work
You write some Rust-like HDL and use the transpiler to turn it into Verilog.

* Contributing
I mainly want your opinions on the syntax of this HDL.

* Syntax/Grammar
This is not the final syntax/grammar, it may change drastically!
#+begin_src text
<ident> := [a-zA-Z_]+;
<int> := [0-9]+;

<namespace> := <namespace> '::' <ident>
			   | <ident>
			   ;
	
<name> := <namespace> '::' <ident>
	   	  | 'self' '.' <ident>
		  | <ident>
		  ;


<subtype> := 'Logic'
		  	 | 'Tri'
		  	 | '[' <subtype> ';' <int> ']'
			 ;

<type> := ('Input' | 'Output' | 'InOut') '<' <subtype> '>'
	   	  | <subtype>
		  ;
	
<expression> := <name>
			 	| <expression> ['+' | '-'] <expression>
				| <name> '{' (<name> (':' <expression>)? ',')* '}'
				| <name> '(' (<expression> ',')* ')'
				| <name> '[' (<int> | <int>? '..' <int>?) ']'
				;

<block-stmt> := '{' <statement>* '}';
				
<statement> := 'if' <expression> <block-stmt> ('else' <block-stmt>)?
			   | <name> ('<=' | '=') <expression>
			   | <block-stmt>
			   ;

<fn-macro> := '#[always_ff(' (<ident> (':' ('posedge' | 'negedge' | 'pos' | 'neg'))?)* ')]'
		   	  | '#[always_comb]'
			  ;
			  
<function> := <fn-macro> 'pub'? 'fn' <ident> '(' (<ident> ':' <type> ',')* ')' ('->' <type>)? <block-stmt>;

<impl> := 'impl' <ident> '{' <function>* '}';
<struct> := 'pub'? 'struct' <ident> '{' ('pub'? <ident> ':' <type> ',')* '}';

<program> := (<struct> | <impl>)*;
#+end_src
** TODO
*** type X = Y;
* Examples
** Accumulator (from llhd.io)
#+begin_src rust
pub struct Accumulator {
	pub clk: Input<Logic>,
	pub direction: Input<Logic>,
	pub increment: Input<[Logic; 16]>,
	pub result: Output<[Logic; 16]>,

	next: [Logic; 16],
}

impl Accumulator {
	pub fn new(clk: Input<Logic>, direction: Input<Logic>, increment: Input<[Logic; 16]>, result: Output<[Logic; 16]>) -> Self {
		Self {
			clk,
			direction,
			increment,
			result,
			// TODO: next
		}
	}
	
	#[always_comb]
	fn increment(&mut self) {
		if self.direction {
			self.result = self.result + self.increment;
		} else {
			self.result = self.result - self.increment;
		}
	}

	#[always_ff(clk: posedge)]
	fn load_result(&mut self) {
		self.result <= self.next;
	}
}

pub struct Top {
	acc: Accumulator,
}

impl Top {
	pub fn new(clk: Input<Logic>, direction: Input<Logic>, increment: Input<[Logic; 16]>, result: Output<[Logic; 16]>) -> Top {
		Self {
			acc: Accumulator::new(clk, direction, increment, result),
		}
	}
}
#+end_src

* Resources/TODO
** [[http://llhd.io][LLHD]]
